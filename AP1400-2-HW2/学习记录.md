# 作业学习记录

## 当前状态
- 项目结构已分析完成
- 头文件 server.h 和 client.h 目前为空，需要实现
- crypto.cpp/h 已提供完整的加密功能

## 错误记录

### 1. Server.h 语法错误 (第一次实现)
- **错误位置**: include/server.h:10, 16, 18, 19
- **问题描述**: 
  - 第10行：构造函数声明不完整，缺少分号和函数体
  - 第16行：`size_t mine` 应该是 `size_t mine()`，缺少括号
  - 第18行：缺少 `#include <map>` 和 `#include <memory>`
  - 第19行：类定义缺少分号
- **修正方法**: 需要补充缺失的语法元素
- **状态**: ✓ 部分修正完成

### 2. Server.h 仍需完善 (第二次修改)
- **错误位置**: include/server.h:11, 缺少头文件和声明
- **问题描述**:
  - 第11行：构造函数声明语法错误 `Server():` 应该是 `Server();`
  - 缺少 `#include <memory>` 头文件
  - 缺少 `class Client;` 前置声明
  - 缺少全局变量 `pending_trxs` 声明
- **状态**: ✓ 已修正

## 知识点记录

### 知识点1: 前置声明 (Forward Declaration)
- **代码**: `class Client;`
- **作用**: 告诉编译器"Client是一个类"，但不需要知道Client的具体内容
- **为什么需要**: Server类中使用了`std::shared_ptr<Client>`，编译器需要知道Client的存在
- **优点**: 避免循环包含问题，加快编译速度
- **场景**: 当两个类互相引用时经常使用

### 知识点2: extern关键字和全局变量
- **代码**: `extern std::vector<std::string> pending_trxs;`
- **含义**: 声明一个外部变量，该变量在其他文件中定义
- **extern作用**: 
  - 在头文件中：声明变量存在，但不创建变量
  - 在源文件中：实际定义和创建变量
- **为什么这样做**: 避免多个文件包含同一头文件时重复定义变量
- **实际定义位置**: 需要在某个.cpp文件中写`std::vector<std::string> pending_trxs;`

### 知识点3: 构造函数
- **代码**: `Server();`
- **作用**: 创建Server对象时自动调用的特殊函数
- **特点**: 
  - 函数名与类名相同
  - 没有返回值类型
  - 用于初始化对象的成员变量
- **为什么需要**: 每个类都需要构造函数来创建对象

### 知识点4: std::map容器
- **代码**: `std::map<std::shared_ptr<Client>, double> clients;`
- **作用**: 关联容器，存储键值对
- **这里的含义**: 
  - 键(Key): `std::shared_ptr<Client>` - 指向客户端的智能指针
  - 值(Value): `double` - 客户端的钱包余额
- **为什么用map**: 可以通过客户端对象快速查找对应的余额
- **智能指针**: `std::shared_ptr<Client>`是智能指针，自动管理内存，多个地方可以共享同一个Client对象

### 知识点5: 头文件包含机制
- **问题**: server.cpp中已经有`#include "server.h"`，是否需要重复包含server.h中的头文件？
- **答案**: 不需要！包含头文件时，该头文件中的所有include都会被自动包含
- **原理**: 预处理器会递归地包含所有依赖的头文件
- **例子**: 
  - server.h中有`#include <string>`
  - server.cpp中`#include "server.h"`
  - 那么server.cpp就自动可以使用std::string了
- **何时需要额外包含**: 
  - 当.cpp文件使用了头文件中没有包含的库时
  - 例如：如果用到`std::cout`但server.h中没有`#include <iostream>`

### 知识点6: Server类的存储结构
- **成员变量**: `std::map<std::shared_ptr<Client>, double> clients;`
- **存储内容**: 
  - **键(Key)**: `std::shared_ptr<Client>` - 指向客户端对象的智能指针
  - **值(Value)**: `double` - 该客户端的钱包余额（多少个币）
- **实际含义**: Server维护了一个"客户端账本"
- **例子**: 
  ```
  clients = {
    [Client对象"alice"的指针] -> 5.0,    // alice有5个币
    [Client对象"bob"的指针]   -> 10.25,  // bob有10.25个币
    [Client对象"charlie"的指针] -> 0.5   // charlie有0.5个币
  }
  ```
- **为什么这样设计**: 
  - Server是"银行"，需要知道每个客户有多少钱
  - 使用智能指针共享Client对象，避免重复创建
  - 双向关系：Client知道Server，Server也管理Client的余额

### 知识点7: 构造函数的初始化
- **问题**: Server的构造函数需要做什么初始化工作？
- **答案**: 对于Server类，构造函数可以为空
- **原因**: 
  - `clients` 是 `std::map`，会自动初始化为空map
  - `pending_trxs` 是全局变量，会自动初始化为空vector
  - 没有需要手动初始化的资源（文件、网络连接等）
- **何时需要初始化**: 
  - 基本数据类型成员变量（int、double等）
  - 需要特殊初始值的情况
  - 需要分配资源的情况（内存、文件等）
- **STL容器**: `std::map`, `std::vector`, `std::string` 等都有默认构造函数，会自动初始化为空

### 知识点8: C++类和对象基础概念

#### 什么是类（Class）？
- **定义**: 类是一个"模板"或"蓝图"，定义了一种数据类型
- **比喻**: 类就像"汽车设计图"，定义了汽车应该有什么部件和功能
- **内容**: 类包含成员变量（数据）和成员函数（操作）

#### 什么是对象（Object）？
- **定义**: 对象是类的"实例"，是根据类创建的具体实体
- **比喻**: 对象就像"具体的汽车"，是按照设计图制造出来的真实物品
- **特点**: 每个对象都有自己独立的成员变量值

#### 实际例子
```cpp
// 类的定义（蓝图）
class Car {
private:
    std::string brand;    // 成员变量
    int speed;
public:
    Car(std::string b);   // 构造函数
    void accelerate();    // 成员函数
    int getSpeed();
};

// 创建对象（具体的汽车）
Car car1("Toyota");    // car1是一个对象
Car car2("BMW");       // car2是另一个对象
```

#### 在我们的作业中
- **Server类**: 是"银行"的设计图
- **server对象**: 是具体的银行实例
- **Client类**: 是"客户"的设计图
- **alice, bob等**: 是具体的客户对象

#### 成员变量和成员函数
- **成员变量**: 对象的"属性"（如客户的ID、余额）
- **成员函数**: 对象的"行为"（如转账、挖矿）
- **this指针**: 在成员函数中，this指向当前对象

#### 构造函数
- **作用**: 创建对象时自动调用，用于初始化
- **特点**: 函数名与类名相同，没有返回值类型
- **例子**: `Server::Server()` 就是Server类的构造函数

### 3. Client.h 实现 (第一次)
- **错误位置**: include/client.h:24
- **问题描述**: 类定义后缺少分号
- **修正方法**: 在第24行的 `}` 后面加上分号变成 `};`
- **状态**: ✓ 已修正

### 4. Server.cpp add_client函数 (第一次实现)
- **错误位置**: src/server.cpp:17
- **问题描述**: 函数定义缺少类名限定符
- **当前**: `std::shared_ptr<Client> add_client(std::string id)`
- **应该**: `std::shared_ptr<Client> Server::add_client(std::string id)`
- **原因**: 这是类的成员函数，需要指明属于哪个类
- **状态**: ✓ 已修正

### 5. Server.cpp 三个函数实现检查
- **add_client**: ✓ 实现正确
- **get_client**: ✓ 实现正确  
- **get_wallet**: ⚠️ 有一个小问题

#### get_wallet函数问题：
- **错误位置**: src/server.cpp:51
- **问题**: `logic_error` 前缺少 `std::`
- **当前**: `throw logic_error("this id doesn't exist");`
- **应该**: `throw std::logic_error("this id doesn't exist");`
- **解决方案**: 添加 `std::` 前缀，并需要 `#include <stdexcept>` 头文件
- **状态**: ✓ 已修正

### 6. Client.cpp 三个函数实现检查

#### 函数1: Client::get_id() 
- **状态**: ✅ 完全正确
- **代码**: `return this->id;` 正确返回客户ID

#### 函数2: get_publickey()
- **错误位置**: src/client.cpp:14
- **问题**: 缺少类名限定符和返回语句语法错误
- **当前**: `std::string get_publickey()`
- **应该**: `std::string Client::get_publickey()`
- **额外问题**: `return this->public_key;` 缺少分号

#### 函数3: Server::get_wallet()
- **错误位置**: src/client.cpp:17 (这个函数不应该在client.cpp中！)
- **问题列表**:
  1. 这应该是Client::get_wallet()，不是Server::get_wallet()
  2. 函数体逻辑错误：Client对象不需要调用get_client
  3. 语法错误：`return Server::clients[client_ptr]` 缺少分号
  4. 语法错误：`logic_error` 前缺少 `std::`
- **正确实现应该是**:
  ```cpp
  double Client::get_wallet() {
      return server->get_wallet(id);
  }
  ```

### 7. Client::get_wallet() 函数第二次检查
- **错误位置**: src/client.cpp:20-22, 24
- **问题列表**:
  1. **设计问题**: `Server::get_client()` 不能这样调用，因为它不是静态函数
  2. **访问权限**: `Server::clients` 是private成员，Client类无法直接访问
  3. **语法错误**: 第24行 `return Server::clients[client_ptr]` 缺少分号
  4. **逻辑复杂**: Client不需要自己查找指针，应该委托给Server

#### 正确的简单实现：
```cpp
double Client::get_wallet() {
    return server->get_wallet(id);  // 委托Server查询
}
```

#### 为什么这样更好：
- **封装性**: 遵守访问权限，不直接访问Server的private成员
- **简单性**: 一行代码解决问题
- **正确性**: 利用已经实现好的Server::get_wallet()函数

### 知识点12: 为什么Client::get_wallet()中不需要初始化server和id？
- **问题**: 在get_wallet()函数中直接使用server和id，为什么不需要初始化？
- **答案**: 因为它们已经在构造函数中初始化过了！

#### 详细解释：
1. **server和id是成员变量**，每个Client对象都有这两个属性
2. **构造函数已经初始化**：
   ```cpp
   Client::Client(std::string id, const Server& server) 
       : id(id), server(&server)  // 在这里已经初始化了！
   {
       // 生成密钥的代码...
   }
   ```
3. **成员函数可以直接使用**：
   - `id` 是这个Client对象的身份证号
   - `server` 是指向银行的指针
   - 在任何成员函数中都可以直接使用，不需要重新初始化

#### 对象的生命周期：
```cpp
// 创建Client对象时：
Client alice("alice", myBank);  // 构造函数被调用，id="alice", server=&myBank

// 后来调用get_wallet时：
alice.get_wallet();  // id和server已经存在，直接使用即可
```

#### 类比理解：
- 你出生时就有身份证号（id）和户籍地（server）
- 以后任何时候需要用身份证号，都不需要重新"出生"
- 直接用现有的身份证号即可

### 知识点13: this指针的使用
- **问题**: `get_id()` 函数中可以写 `return id` 而不是 `return this->id` 吗？
- **答案**: 完全可以！两种写法都正确

#### 两种等价的写法：
```cpp
// 写法1：使用this指针（显式）
std::string Client::get_id() {
    return this->id;
}

// 写法2：直接使用成员变量（隐式）
std::string Client::get_id() {
    return id;
}
```

#### 编译器的处理：
- 当你写 `return id` 时，编译器自动理解为 `return this->id`
- `this` 是隐含的，指向当前对象
- 两种写法编译后的代码完全相同

#### 何时需要显式使用this？
1. **参数名与成员变量同名时**：
   ```cpp
   void Client::setId(std::string id) {
       this->id = id;  // 必须用this区分参数id和成员变量id
   }
   ```
2. **为了代码清晰性**（可选）
3. **在某些模板编程场景中**

#### 推荐写法：
- 一般情况下：`return id;`（简洁）
- 有歧义时：`return this->id;`（明确）

### 8. Server::parse_trx() 函数检查
- **错误位置**: src/server.cpp:61
- **语法错误**: `logic_error` 前缺少 `std::`
- **应该**: `throw std::logic_error("this trx is not standard");`

#### 函数逻辑问题：
- **当前实现**: 只是检查字符串格式是否匹配，然后返回true/false或抛异常
- **README要求**: "parse this string format and outputting each property separately"
- **问题**: 函数签名表明应该解析输入，但实际上是在验证输出

#### 正确理解：
根据函数签名 `parse_trx(trx, sender, receiver, value)`，这个函数应该：
1. 接收一个交易字符串 `trx`（如"alice-bob-1.5"）
2. 解析出 sender, receiver, value
3. 通过引用参数返回解析结果
4. 如果解析失败，抛出异常

#### 建议的正确实现：
函数应该解析输入的trx字符串，将结果填入sender, receiver, value参数中

### 知识点14: C++字符串分割方法
- **问题**: 如何将 "alice-bob-1.5" 分割成三部分？
- **方法**: 使用 `std::string` 的 `find()` 和 `substr()` 函数

#### 基本概念：
- `find(char)` - 查找字符的位置，返回索引
- `substr(start, length)` - 提取子字符串
- 如果找不到字符，`find()` 返回 `std::string::npos`

#### 分割示例：
```cpp
std::string trx = "alice-bob-1.5";

// 查找第一个'-'的位置
size_t first_dash = trx.find('-');        // 结果：5
// 查找第二个'-'的位置（从第一个'-'之后开始）
size_t second_dash = trx.find('-', first_dash + 1);  // 结果：9

// 提取各部分
std::string sender = trx.substr(0, first_dash);           // "alice"
std::string receiver = trx.substr(first_dash + 1, 
                                second_dash - first_dash - 1);  // "bob"
std::string value_str = trx.substr(second_dash + 1);      // "1.5"

// 转换value为double
double value = std::stod(value_str);  // 1.5
```

#### 错误检查：
```cpp
if (first_dash == std::string::npos || second_dash == std::string::npos) {
    throw std::runtime_error("Invalid transaction format");
}
```

### 知识点15: std::string::npos的含义
- **npos是什么**: "no position" 的缩写，表示"没有找到位置"
- **数值**: 是一个很大的数（通常是 size_t 类型的最大值）
- **用途**: 当 `find()` 函数找不到指定字符时，返回 `npos`

#### 使用示例：
```cpp
std::string text = "hello world";
size_t pos = text.find('x');  // 找不到'x'，返回 std::string::npos

// 检查是否找到
if (pos == std::string::npos) {
    std::cout << "没找到字符 'x'" << std::endl;
} else {
    std::cout << "找到了，位置在: " << pos << std::endl;
}
```

#### 常见错误：
- ❌ `std::nops` (拼写错误)
- ✅ `std::string::npos` (正确写法)

### 9. parse_trx函数实现检查 (第一次尝试)
- **错误位置**: src/server.cpp:60, 62, 63, 65
- **问题列表**:
  1. **拼写错误**: `std::nops` 应该是 `std::string::npos`
  2. **语法错误**: 第60行if语句不完整，缺少条件和大括号
  3. **函数调用错误**: `std::substr()` 不存在，应该是 `trx.substr()`
  4. **参数问题**: `substr(0, first_place - 1)` 参数错误，应该是 `substr(0, first_place)`
  5. **类型错误**: 函数参数需要是引用类型才能修改

#### 需要修正的地方：
```cpp
// 当前（错误）：
if(first_place == std::nops)          // 拼写错误 + 语句不完整
sender = std::substr(0, first_place - 1);  // 函数不存在 + 参数错误

// 应该是：
if(first_place == std::string::npos || second_place == std::string::npos) {
    throw std::runtime_error("Invalid format");
}
sender = trx.substr(0, first_place);  // 使用trx对象的substr方法
```

### 10. parse_trx函数第二次检查
- **错误位置**: src/server.cpp:64, 68
- **问题**: 
  1. 第64行：`substr(0, first_place - 1)` 应该是 `substr(0, first_place)`
  2. 第68行：函数没有返回值，应该添加 `return true;`
- **状态**: ✓ 已修正

### 11. transfer_money函数实现错误 (第一次实现)
- **错误位置**: src/client.cpp:29, 34
- **问题描述**:
  1. **拼写错误**: `sign(fianl_trx)` 中的 `fianl_trx` 应该是 `final_trx`
  2. **函数调用错误**: `Server::add_pending_trx()` 不能直接调用，应该通过对象指针调用
  3. **逻辑顺序错误**: 应该先检查余额再签名，避免不必要的计算
- **正确调用**: `server->add_pending_trx(final_trx, sign_trx)`
- **状态**: ✓ 已修正

### 12. add_pending_trx函数实现错误 (第一次实现)  
- **错误位置**: src/server.cpp:75, 76, 77, 80, 81
- **问题描述**:
  1. **引用参数错误**: `parse_trx(trx, &sender, &receiver, &value)` 中不需要 `&`，因为参数已经是引用类型
  2. **函数调用错误**: `get_wallet(sender)` 正确，但需要先检查sender客户是否存在  
  3. **类型错误**: `sender.get_publickey()` 错误，`sender`是string类型，需要先获取Client对象
  4. **容器方法错误**: `pending_trxs.add(trx)` 应该是 `pending_trxs.push_back(trx)`
  5. **类型声明不完整**: `std::shared_ptr client_sender` 缺少模板参数
- **修正要点**:
  - 引用参数: `parse_trx(trx, sender, receiver, value)`
  - 获取Client对象: `std::shared_ptr<Client> client_sender = get_client(sender)`
  - 使用正确的容器方法: `push_back()`
- **状态**: ✓ 已修正

### 知识点17: C++智能指针模板参数
- **问题**: `std::shared_ptr client_sender` 编译错误
- **原因**: `std::shared_ptr` 是模板类，必须指定类型参数
- **正确写法**: `std::shared_ptr<Client> client_sender`
- **类比理解**: 
  - `std::vector` → `std::vector<int>` (必须指定存储什么类型)
  - `std::shared_ptr` → `std::shared_ptr<Client>` (必须指定指向什么类型)
- **模板语法**: `模板名<类型参数>`

### 知识点18: C++引用参数的使用
- **引用参数定义**: `void func(int& param)` - 参数是引用类型
- **调用引用函数**: `func(variable)` - 直接传变量，不需要 `&`
- **取地址 vs 引用**: 
  - `&variable` - 取地址，用于指针参数
  - `variable` - 变量本身，用于引用参数
- **错误示例**: `func(&variable)` 当func期望引用参数时
- **正确示例**: `func(variable)` 编译器自动处理引用

### 知识点19: vector容器的方法
- **添加元素**: `vector.push_back(element)` - 在末尾添加元素
- **常见错误**: `vector.add(element)` - vector没有add方法
- **其他方法**: 
  - `push_front()` - deque有，vector没有
  - `insert()` - 在指定位置插入
  - `emplace_back()` - 直接在末尾构造元素

### 知识点10: std::make_shared函数
- **是什么**: `std::make_shared` 是C++标准库函数，定义在 `<memory>` 头文件中
- **作用**: 创建对象并用智能指针管理它

### 知识点16: Client::sign()函数的作用和实现
- **作用**: 数字签名，用于证明数据确实来自私钥持有者
- **应用场景**: 在转账时，Client需要用私钥签名交易，证明"这笔转账确实是我发起的"

#### 数字签名的原理：
1. **私钥签名**: 只有私钥持有者能够创建有效签名
2. **公钥验证**: 任何人都可以用公钥验证签名的真实性
3. **防止伪造**: 没有私钥的人无法伪造签名

#### 在加密货币中的应用：
```cpp
// alice要转账给bob
std::string transaction = "alice-bob-1.5";
std::string signature = alice.sign(transaction);  // alice用私钥签名
// 现在alice可以提交 transaction + signature 到服务器
// 服务器可以用alice的公钥验证这确实是alice发起的转账
```

#### 简单实现：
```cpp
std::string Client::sign(std::string txt) {
    return crypto::signMessage(private_key, txt);
}
```

#### 为什么需要签名？
- **身份认证**: 证明交易确实来自账户持有者
- **防止篡改**: 如果数据被修改，签名验证会失败
- **不可否认**: 签名者无法否认自己签署过这个数据
- **语法**: `std::make_shared<类型>(构造函数参数...)`
- **返回值**: `std::shared_ptr<类型>` 智能指针

#### 详细解释
```cpp
// 语法格式
std::make_shared<ClassName>(constructor_parameters...)

// 在我们的例子中
std::make_shared<Client>(id, *this)
//                ^      ^    ^
//              类型   参数1  参数2
```

#### 为什么用make_shared？
- **自动内存管理**: 不需要手动delete，智能指针会自动释放内存
- **异常安全**: 如果构造失败，内存会自动清理
- **性能优化**: 比 `new` + `shared_ptr` 更高效

#### 等价的传统写法（不推荐）
```cpp
// 传统方法（容易出错）
Client* raw_ptr = new Client(id, *this);
std::shared_ptr<Client> smart_ptr(raw_ptr);

// 现代方法（推荐）
auto smart_ptr = std::make_shared<Client>(id, *this);
```

#### 智能指针的好处
- **共享所有权**: 多个指针可以指向同一个对象
- **自动销毁**: 当没有指针指向对象时，自动删除对象
- **防止内存泄漏**: 不需要记住delete

### 知识点11: get_client函数的查找逻辑
- **问题**: 为什么能用ID字符串找到Client指针？
- **答案**: 不是直接转换，而是通过遍历查找
- **原理**: 
  1. clients存储的是 `map<Client指针, 余额>`
  2. 每个Client对象内部有ID属性
  3. 遍历所有Client对象，找到ID匹配的那个
- **查找过程**:
  ```
  输入: "alice"
  遍历: clients中的每个Client对象
  比较: client->get_id() == "alice" ?
  找到: 返回匹配的Client指针
  没找到: 返回nullptr
  ```

## 下一步计划
1. ✓ 分析作业要求中的类定义
2. ✓ 实现 Server 类头文件  
3. ✓ 完善 Client 类头文件
4. 🔄 开始实现具体功能
3. 实现 Client 类头文件
4. 实现具体功能